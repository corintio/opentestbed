package game;

import java.io.IOException;
import java.io.Writer;
import java.text.DateFormat;
import java.text.DecimalFormat;
import java.text.DecimalFormatSymbols;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.TreeMap;
import java.util.Map.Entry;
import java.util.logging.Level;
import java.util.logging.Logger;

import com.biotools.meerkat.Action;
import com.biotools.meerkat.Card;
import com.biotools.meerkat.GameInfo;
import com.biotools.meerkat.GameObserver;
import com.biotools.meerkat.Hand;

/**
 * A HandHistoryWriter observes a game and on a {@link #gameOverEvent()} writes a hand-history-file to a given {@link Writer} in Full-Till format.<br>
 * Please note that the format is not 100% FullTilt, but shortened to the most important information that importers (like PokerTracker and HoldemManager) need
 * for correct processing.
 */

public class HandHistoryWriter implements GameObserver {
	Logger log = Logger.getLogger(this.getClass().getName());

	private GameInfo gameInfo;
	private Writer outWriter;
	private StringBuffer currentHistory = new StringBuffer();
	private DecimalFormat moneyFormat = new DecimalFormat("0.00", new DecimalFormatSymbols(Locale.ENGLISH));
	private List<Double> potsAtShowDown;
	private List<Boolean> tiedPotsAtShowDown;
	private Map<Integer, List<Card>> handShown = new TreeMap<Integer, List<Card>>();
	private Map<Integer, Double> amountWon = new TreeMap<Integer, Double>();
	// values could be taken from gameInfo, but this is not ready yet
	private Map<Integer, Double> amountInPotThisRound = new TreeMap<Integer, Double>();

	public void setWriter(Writer outWriter) {
		this.outWriter = outWriter;
	}

	@Override
	public void actionEvent(int pos, Action act) {
		double inPotThisRound = amountInPotThisRound.get(pos);

		currentHistory.append(gameInfo.getPlayerName(pos)).append(" ");
		switch (act.getType()) {
		case Action.SMALL_BLIND:
			currentHistory.append("posts the small blind of $").append(moneyFormat.format(act.getAmount())).append("\n");
			amountInPotThisRound.put(pos, inPotThisRound + act.getAmount());

			break;
		case Action.BIG_BLIND:
			currentHistory.append("posts the big blind of $").append(moneyFormat.format(act.getAmount())).append("\n");
			currentHistory.append("The button is in seat #").append(gameInfo.getButtonSeat() + 1).append("\n");
			amountInPotThisRound.put(pos, inPotThisRound + act.getAmount());
			break;
		case Action.CALL:
			currentHistory.append("calls $").append(moneyFormat.format(act.getToCall())).append("\n");
			amountInPotThisRound.put(pos, inPotThisRound + act.getToCall());
			break;
		case Action.RAISE:
			currentHistory.append("raises to $").append(moneyFormat.format(inPotThisRound + act.getToCall() + act.getAmount())).append("\n");
			amountInPotThisRound.put(pos, inPotThisRound + act.getToCall() + act.getAmount());
			break;

		case Action.CHECK:
			currentHistory.append("checks\n");
			break;
		case Action.FOLD:
			currentHistory.append("folds\n");
			break;
		case Action.MUCK:
			currentHistory.append("mucks\n");
			break;
		default:
			throw new IllegalStateException("Action " + act + " not supported (yet)");

		}
		// TODO Auto-generated method stub
	}

	@Override
	public void dealHoleCardsEvent() {
		currentHistory.append("*** HOLE CARDS ***\n");
	}

	@Override
	public void gameOverEvent() {
		writeSummaryGameInfo();

		if (outWriter != null) {
			try {
				outWriter.write(currentHistory.toString());
				outWriter.flush();
			} catch (IOException e) {
				// currently we don't rethrow so to not disturb the game ?
				log.log(Level.SEVERE, "error writing handhistory", e);
			}
		} else {
			log.severe("no writer set, can't write HandHistory");
		}
		currentHistory = new StringBuffer();
	}

	@Override
	public void gameStartEvent(GameInfo gInfo) {
		this.gameInfo = gInfo;
		amountWon = new TreeMap<Integer, Double>();
		handShown = new TreeMap<Integer, List<Card>>();
		amountInPotThisRound = new TreeMap<Integer, Double>();
		potsAtShowDown = null;
		tiedPotsAtShowDown = null;
		for (int i = 0; i < gameInfo.getNumSeats(); i++) {
			amountWon.put(i, Double.valueOf(0));
		}
		writeInitalGameInfo();
	}

	@Override
	public void gameStateChanged() {
	}

	@Override
	public void showdownEvent(int seat, Card c1, Card c2) {
		currentHistory.append(gameInfo.getPlayerName(seat)).append(" shows ");
		currentHistory.append("[").append(c1).append(" ").append(c2).append("]\n");
		handShown.put(seat, Arrays.asList(c1, c2));
	}

	@Override
	public void stageEvent(int stage) {
		for (int i = 0; i < gameInfo.getNumSeats(); i++) {
			amountInPotThisRound.put(i, Double.valueOf(0));
		}

		switch (stage) {
		case 0:
			break; // preflop not interesting
		case 1:
			currentHistory.append("*** FLOP *** ");
			currentHistory.append(renderBoard(false)).append("\n");
			break;
		case 2:
			currentHistory.append("*** TURN *** ");
			currentHistory.append(renderBoard(true)).append("\n");
			break;
		case 3:
			currentHistory.append("*** RIVER *** ");
			currentHistory.append(renderBoard(true)).append("\n");
			break;
		default:
			throw new IllegalStateException("stage " + stage + "not supported");
		}
	}

	public String renderBoard(boolean highlightLastCard) {
		Hand board = gameInfo.getBoard();
		String renderString = "[";
		for (int i = 0; i < board.size(); i++) {
			renderString += board.getCard(i + 1);
			if (highlightLastCard && (i == board.size() - 2)) {
				renderString += "] [";
			} else if (i < board.size() - 1) {
				renderString += " ";
			}
		}
		renderString += "]";
		return renderString;
	}

	@Override
	public void winEvent(int pos, double amount, String handName) {
		// player5 wins the pot ($0.05)
		// player6 ties for the pot	($x.xx)
		if (potsAtShowDown == null) {
			potsAtShowDown = new ArrayList<Double>();
			tiedPotsAtShowDown = new ArrayList<Boolean>();
			potsAtShowDown.add(Double.valueOf(gameInfo.getMainPotSize()));
			tiedPotsAtShowDown.add(Boolean.FALSE);
			for (int i = 0; i < gameInfo.getNumSidePots(); i++) {
				potsAtShowDown.add(new Double(gameInfo.getSidePotSize(i)));
				tiedPotsAtShowDown.add(Boolean.FALSE);
			}
		}
		currentHistory.append(gameInfo.getPlayerName(pos));
		if (potsAtShowDown.size() > 0) {
			int currentPot = potsAtShowDown.size() - 1;
			double currentSidePotAmount = potsAtShowDown.get(currentPot);
			if (amount < currentSidePotAmount) {
				tiedPotsAtShowDown.set(currentPot, Boolean.TRUE);
			}
			if (tiedPotsAtShowDown.get(currentPot)) {
				currentHistory.append(" ties for the pot ");
			} else {
				currentHistory.append(" wins the pot ");
			}
			currentSidePotAmount -= amount;
			if (currentSidePotAmount < 0.001) {
				potsAtShowDown.remove(currentPot);
				tiedPotsAtShowDown.remove(currentPot);
			} else {
				potsAtShowDown.set(currentPot, Double.valueOf(currentSidePotAmount));
			}
		}
		currentHistory.append("($").append(moneyFormat.format(amount)).append(")\n");

		double playerAmountWon = amountWon.get(pos);
		amountWon.put(pos, playerAmountWon + amount);
	}

	/**
	 * Writes the beginning Header
	 * 
	 * <pre>
	 * Full Tilt Poker Game #19342777650: Table Jay (shallow) - $0.01/$0.02 - No Limit Hold'em - 18:21:50 ET - 2010/03/17
	 * Seat 1: player1 ($0.33)
	 * Seat 3: player3 ($0.42)
	 * </pre>
	 * 
	 */
	private void writeInitalGameInfo() {
		// First line:
		// Full Tilt Poker Game #19342777650: Table Jay (shallow) - $0.01/$0.02 - No Limit Hold'em - 18:21:50 ET - 2010/03/17
		currentHistory.append("Full Tilt Poker Game #").append(gameInfo.getGameID());
		currentHistory.append(": Table OpenTestBed - $");
		currentHistory.append(moneyFormat.format(gameInfo.getSmallBlindSize()));
		currentHistory.append("/$");
		currentHistory.append(moneyFormat.format(gameInfo.getBigBlindSize()));
		currentHistory.append(" - ").append(gameInfo.isNoLimit() ? "No " : gameInfo.isPotLimit() ? "Pot " : "").append("Limit Hold'em");

		DateFormat dateFormat = new SimpleDateFormat("hh:mm:ss z - yyyy/MM/dd");
		currentHistory.append(" - ").append(dateFormat.format(getGameTime()));
		currentHistory.append("\n");

		if (gameInfo.isActive(9)) {
			throw new IllegalStateException("Full-Tilt format only supports 9 players, but 10 players are seated");
		}

		// Player Seats
		// Seat 1: player1 ($0.33)
		for (int playerId = 0; playerId < 9; playerId++) {
			if (gameInfo.isActive(playerId)) {
				currentHistory.append("Seat ").append(playerId + 1).append(": ");
				currentHistory.append(gameInfo.getPlayerName(playerId));
				currentHistory.append(" ($").append(moneyFormat.format(gameInfo.getBankRoll(playerId))).append(")\n");
			}
		}
	}

	//Seat 1: redilts collected ($0.02)			
	//Seat 4: player4 showed [Ad As] and won ($2.30)

	private void writeSummaryGameInfo() {
		currentHistory.append("*** SUMMARY ***\n");
		for (Entry<Integer, Double> playerAmountWon : amountWon.entrySet()) {
			int seat = playerAmountWon.getKey();
			double amount = playerAmountWon.getValue();
			if (amount < 0.001) {
				continue;
			}
			currentHistory.append("Seat ").append(seat + 1);
			currentHistory.append(": ").append(gameInfo.getPlayerName(seat));
			List<Card> cards = handShown.get(seat);
			if (cards != null) {
				currentHistory.append(" showed [").append(cards.get(0)).append(" ").append(cards.get(1)).append("] and won ");
			} else {
				currentHistory.append(" collected ");
			}
			currentHistory.append("($").append(moneyFormat.format(amount)).append(")\n");
		}

	}

	/**
	 * to be overridden by JUnit-Tests
	 * @return
	 */
	protected Date getGameTime() {
		return new Date();
	}

}
